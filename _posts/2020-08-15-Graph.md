---

title: Graph
date: 2020-08-15 23:00-0800
categories:
-   DataStructure
tags:
- DataStrcture Graph
---

## 图

### 邻接矩阵存储法 <!--顺序存储-->

> 特点：删除边很方便，删除顶点需要移动大量数据。

```c
#define MaxVertexNum 100
#define INFINITY 9999
typedef char VertexType;
typedef int EdgeType;
typedef struct{
    VertextType Vex[MaxVertexNum];
    EdgeType Edge[MaxVertexNum][MaxVertexNum]
    int vexnum, arcnum;		//图的当前结点数和边数/弧数
}MGraph;
```

### 邻接表法<!--顺序+链式-->

<!--typedef struct + "NickName"{}a;-->

<!--typedef的作用等于给结构体设置一个别名-->

<!--strcut NickName{}a[100];等于 struct NickName;  Nickname a[100]-->

> 特点：无向图中删除边或者顶点都不方便，找有向图的入边必须遍历整个邻接表。

```c
typedef struct ArcNode{
    int adjvex;
    struct ArcNode *next;
    #InfoType info;
}ArcNode;
```

```c
typedef struct VNode{
    VertexType data;
    ArcNode *first;
}VNode, AdList[MaxVertexNum];
```

```c
typedef struct{
    AdjList vertices;
    int  vexnum, arcnum;
}ALGraph;
```

### 十字链表存储有向图

> 特点：既解决了邻接矩阵空间复杂度高的问题，也解决了邻接表中找有向图入边必须遍历整个邻接表的问题。

- 弧结点：tailvex headvex hlink tlink info
- 顶点结点：data firstin firstout

### 邻接多重表无向图

> 特点：既解决了邻接矩阵空间复杂度高的问题，也解决了邻接表中无向图删除边或顶点不方便的问题。

- 边结点：i j ilink jlink info
- 顶点结点：data firstege
- 优点：删除边，删除结点很方便

### 图的基本操作：

- **Adjacent(G,x,y)**	//判断是否存在边
- **Neibghbors(G,x)**   //列出与结点x邻接的边
- **InsertVertex(G,x)**
- **DeleteVertex(G,x)**
- **AddEdge(G,x,y)**
- **RemoveEdge(G,x,y)**
- **FirstNeighbor(G,x)**  //求图中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，返回-1
- **NextNeighbor(G,x,y)**  //假设图中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1
- **Get_edge_value(G,x,y)**
- **Set_edge_value(G,x,y,v)**

### 图的遍历

> 图与树的遍历的区别是：图的任一顶点都可能和其余顶点相邻接，为了避免同一顶点被访问多次，必须记下每个顶点的访问信息，设置一个辅助数据visited[0,...,n-1]
>
> 图的遍历实质上是对每个顶点查找其邻接点的过程，耗费时间取决于图的存储结构。

#### 深度优先遍历

```c
bool visited[MaxVertexNum];
void DFSTraverse(Graph G){
    for(int i=0; i<G.vexnum; ++i)
        visited[i] = true;
    for(int j=0; j<G.vexnum; ++j)
        if(!vivisted[j])
            DFS(G,v);
}
void DFS(Graph G, int v){
    int p;
    visit(v);
    visited[v] = true;
    for(p=FirstNeighbor(G,v); p>=0; p=NextNeighbor(G,v,p))
        if(!vivisted[p])
            DFS(G,w);
}
```



#### 广度优先遍历

```c
bool visited[MaxVertexNum];
void BSFTraverse(Graph G){
    //++i的原因是我们空出第一个位置使得下标对齐
    for(int i=0; i<G.vexnum; ++i)
        visited[i] = false;
    InitQueue(Q);
    //调用BFS的次数等于连通分量的个数
    for(int j=0; j<G.vexnum; ++j)
        if(!visited[j])
            BFS(G,j);
}
void BFS(Graph G, int v){
    int p;	//遍历变量
    visit(v);
    visited[v] = true;
    EnQueue(Q,v);
    while(!isEmpty){
        DeQueue(Q,v);
        for(p=FirstNeighbor(G,v); p>=0; p=NextNeighbor(G,v,p))
            if(!visited[p]){
                visit(p);
                visited[p] = true;
                EnQueue(Q,p);
            }
    }
}
```

### 图的应用

#### <!--生成树-->

##### <!--深度优先遍历生成树-->

##### <!--广度优先遍历生成树-->

#### 最小生成树

> Q：假设要在n个城市之间建立通信联络网，则连通n个城市只需要n-1条线路。那么，如何在最节省经费的前提下建立这个通信网。每两个城市之间都可以设置一条道路，最多可能$$n(n-1)/2$$条线路，那么如何选择$$n-1$$条，使得总耗费最少。
>
> A：连通网来表示问题，顶点表示城市，边表示两城市之间的道路，边的权值表示相应的代价。对于n个顶点的连通网可以建立多个不同的生成树，每一棵生成树都可以是是一个连通网。即构造联通网的最小代价生成树(Minimum Cost Spanning Tree)。
>
> MST的性质，假设$$n=(V,{E})$$是一个连通网，$$U$$是一个顶点集的非空子集。若$$(u,v)$$是一个具有最小权值的边，其中$$u∈U，v∈V-U$$，则必存在一棵包含边$$(u,v)$$的最小生成树。

```c
//general algorithm
MST(Graph G){
    T=null;
    while T 未形成一棵生成树；
        do 找到一条最小代价边(u,v)并且加入T后不会产生回路；
            T=T∪(u,v);
}
```



##### prim

```c
//prim的算法时间复杂度为O(|V|^2)
void prim(G,T){
    T = 空;	//初始化空树
    U = {randomvertex};	//添加任一顶点
    while({V-U}!=空){	//若树中不含全部顶点
        设(u,v)满足u∈U，v∈V，且权值最小的边;	
        T = T∪{(u,v)};	//边归入树
        U = U∪{v};	//顶点归入树
    }
}
```



##### kruskal

```c
/kruskal的算法时间复杂度为O(|E|log|E|)
void kruskal(V,T){
    T = V;	//初始化树，仅含顶点
    numS = n;	//连通分量数
    while(numS>1){	//若连通分量数大于1
        从E中取出权值最小的边(v,u);
        if(v和u属于T中不同的连通分量){
            T = T∪{(v,u)};	//将此边加入生成树中
            numS--;	//连通分量减1
        }
    }
}
```

